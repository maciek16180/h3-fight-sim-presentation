{
	"version": 3,
	"file": "h3_fight_sim/__javascript__/combat.mod.js",
	"sources": [
		"h3_fight_sim/combat.py"
	],
	"sourcesContent": [
		"from random import random\n\nfrom unit import make_unit, Stack\n\n\ndef fight(stackA, stackB, num_iter):\n    wins = {stackA.name: [0, 0],\n            stackB.name: [0, 0]}\n\n    def units_order(s1, s2):\n        temp = sorted([s1, s2], key=lambda x: x.speed, reverse=True)\n        if s1.speed == s2.speed and random() < .5:\n            return reversed(temp)\n        return temp\n\n    # __pragma__('kwargs')\n\n    def melee_hit(current, other):\n        if (other.name == 'Azure Dragon' and\n                not current.is_nonliving() and\n                random() < .1):\n            return other, current\n\n        stun_break_bonus = False\n        if not current.is_stunned():\n            stun_break_bonus = (other.is_stunned() and\n                                not other.stunned_from_retaliation)\n            recovery_blindness = other.blinded > 0\n            recovery_paralysis = other.paralyzed > 0\n\n            dmg_reductions = []\n            if other.petrified:\n                dmg_reductions.append(.5)\n\n            current.attack_melee(\n                other,\n                dmg_reductions=dmg_reductions,\n                melee_penalty=current.melee_penalty())\n\n            if (other.is_alive() and\n                    not current.no_retaliation()\n                    and not other.is_stunned()):\n                retaliation_dmg_reductions = []\n                if recovery_paralysis:\n                    retaliation_dmg_reductions.append(.75)\n                elif recovery_blindness:\n                    retaliation_dmg_reductions.append(.5)\n                other.attack_melee(\n                    current,\n                    dmg_reductions=retaliation_dmg_reductions,\n                    melee_penalty=other.melee_penalty(),\n                    retaliation=True)\n\n            if (current.is_alive() and\n                    current.strikes_twice() and\n                    other.is_alive() and\n                    not current.is_stunned()):\n                current.attack_melee(other)\n\n        current.advance_statuses()\n\n        if other.name in ['Wight', 'Wraith', 'Troll'] and other.is_alive():\n            other.regenerate()\n\n        # other gets extra turn if stun just ended and it missed\n        # an action this combat round\n        if (stun_break_bonus and\n                not other.is_stunned() and\n                other.is_alive() and\n                current.is_alive() and\n                ((current.speed < other.speed) or\n                 (current.speed == other.speed and random() < .5))):\n            melee_hit(other, current)\n\n        return other, current\n\n    # __pragma__('nokwargs')\n\n    def range_hit(current, other, penalty):\n        penalty = current.range_penalty() if penalty else False\n        current.attack_range(other, penalty)\n        if current.shoots_twice() and current.shots > 0:\n            current.attack_range(other, penalty)\n        if other.name in ['Wight', 'Wraith', 'Troll'] and other.is_alive():\n            other.regenerate()\n        return other, current\n\n    def fight_to_death(current, other):\n        while current.is_alive() and other.is_alive():\n            current, other = melee_hit(current, other)\n        return current, other\n\n    def walker_vs_shooter(walker, shooter):\n\n        to_walk = starting_dist - 1\n        first_move = to_walk % walker.speed\n        if first_move == 0:\n            first_move = walker.speed\n        avoid_by_move = to_walk - first_move > 10\n        avoid_by_wait = False\n\n        if walker.speed < shooter.speed:\n            num_shots = to_walk // walker.speed + (to_walk % walker.speed > 0)\n        elif walker.speed > shooter.speed:\n            num_shots = to_walk // walker.speed - (to_walk % walker.speed == 0)\n            avoid_by_wait = True\n        else:\n            if random() < .5:\n                num_shots = to_walk // walker.speed + \\\n                    (to_walk % walker.speed > 0)\n            else:\n                num_shots = to_walk // walker.speed - \\\n                    (to_walk % walker.speed == 0)\n\n        num_full_shots = max(0, num_shots - avoid_by_move - avoid_by_wait)\n        num_half_shots = num_shots - num_full_shots\n\n        for j in range(num_half_shots):\n            range_hit(shooter, walker, True)\n        for j in range(num_full_shots):\n            range_hit(shooter, walker, False)\n\n        current, other = walker, shooter\n        return fight_to_death(current, other)\n\n    starting_dist = 14\n    if stackA.is_big():\n        starting_dist -= 1\n    if stackB.is_big():\n        starting_dist -= 1\n\n    for it in range(num_iter):\n        current, other = units_order(stackA, stackB)\n\n        if not current.is_shooter() and not other.is_shooter():\n            current, other = fight_to_death(current, other)\n\n        elif current.is_shooter() and other.is_shooter():\n            full_round = True\n            while (current.is_alive() and\n                    ((current.shots > 0 and other.shots > 0)\n                        or not full_round)):\n                current, other = range_hit(current, other, True)\n                full_round = not full_round\n            if current.is_alive():\n                if current.shots == 0 and other.shots == 0:\n                    current, other = units_order(current, other)\n                    current, other = fight_to_death(current, other)\n                else:\n                    shooter = current if current.shots > 0 else other\n                    walker = current if current.shots == 0 else other\n                    current, other = walker_vs_shooter(walker, shooter)\n\n        else:\n            shooter = current if current.is_shooter() else other\n            walker = current if not current.is_shooter() else other\n            current, other = walker_vs_shooter(walker, shooter)\n\n        winner = current if current.is_alive() else other\n        wins[winner.name][0] += 1\n        wins[winner.name][1] += winner.count\n\n        stackA.reset_state()\n        stackB.reset_state()\n\n    for s in [stackA.name, stackB.name]:\n        if wins[s][0]:\n            wins[s][1] /= float(wins[s][0])\n\n    return wins\n\n\ndef find_balance(nameA, nameB, num_iter, startA):\n\n    if nameA == nameB:\n        if startA:\n            return startA, startA\n        return 1, 1\n\n    def balanced(result):\n        return (num_iter // 2) * .95 < \\\n            result[A.name][0] < \\\n            (num_iter // 2) * 1.05\n\n    unitA = make_unit(nameA)\n    unitB = make_unit(nameB)\n\n    startA = startA or unitB.ai_value * 10\n    startB = int(float(startA) / unitB.ai_value * unitA.ai_value)\n\n    print(startA, startB)\n\n    A = Stack(unitA, startA)\n    B = Stack(unitB, startB)\n\n    res = fight(A, B, num_iter)\n    print(res)\n\n    if balanced(res):\n        return A.count, B.count\n\n    B_won_last = res[A.name][0] < res[B.name][0]\n    sign = -1 if B_won_last else 1\n    change = sign * max(int(B.count / 10.), 1)\n    enough = False\n\n    while not enough:\n        print(B.count)\n        x1 = B.count\n        B.count += change\n        B.cap += change\n        res = fight(A, B, num_iter)\n        print(res)\n\n        B_won = res[A.name][0] < res[B.name][0]\n        enough = B_won != B_won_last\n        if not enough:\n            B_won_last = B_won\n\n    if balanced(res):\n        return A.count, B.count\n\n    x2 = B.count\n\n    low = min(x1, x2)\n    high = max(x1, x2)\n    print(\"\\n\", low, high, \"\\n\")\n    # here binsearch from [low, high] for balanced result\n    while True:\n        middle = low + (high - low) // 2\n        print(middle)\n        B.count = middle\n        B.cap = middle\n        res = fight(A, B, num_iter)\n        print(res)\n        if balanced(res) or abs(high - low) <= 1:\n            return A.count, max(B.count, 1)\n        B_won = res[A.name][0] < res[B.name][0]\n        if B_won:\n            high = middle - 1\n        else:\n            low = middle + 1\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAKA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AAAA;AAMA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AASA;AACA;AAAA;AAEA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}