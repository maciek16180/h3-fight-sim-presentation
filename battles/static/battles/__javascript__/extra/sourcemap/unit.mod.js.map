{
	"version": 3,
	"file": "h3_fight_sim/__javascript__/unit.mod.js",
	"sources": [
		"h3_fight_sim/unit.py"
	],
	"sourcesContent": [
		"from math import ceil, pi, cos, log\nfrom random import random, randint\n\nfrom crtraits import data, haters, elementals\n\n\nkeywords = {\n    'DOUBLE_WIDE',\n    'SHOOTING_ARMY',\n    'const_free_attack',\n    'const_jousting',\n    'const_no_melee_penalty',\n    'const_two_attacks',\n    'IS_UNDEAD',\n    'cusELEMENTAL',\n    'cusGOLEM'\n}\n\n\n# Box-Muller transform\ndef my_gauss(mu, sigma):\n    return sigma * ((-2*log(random()))**.5 * cos(2*pi*random())) + mu\n\n\n# for sufficiently large n we can use much faster normal approximation\ndef my_binomial(n, p):\n    if n < 100:\n        return sum(random() < p for _ in range(int(n)))\n    return int(my_gauss(n*p, (n*p*(1-p))**.5))\n\n\ndef my_divmod(n, m):\n    div = n // m\n    mod = n - m * div\n    return div, mod\n\n\ndef make_unit(name):\n    assert name in data\n    # return UnitType(*([name] + data[name]))\n    d = data[name]\n    return UnitType(name, d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8])\n\n\nclass UnitType(object):\n\n    def __init__(self, name, aiv, hp, spd, att, df,\n                 dmlow, dmhi, shots, abi):\n        self.name = name\n        self.ai_value = aiv\n        self.hp = hp\n        self.speed = spd\n        self.attack = att\n        self.defense = df\n        self.dmg_min = dmlow\n        self.dmg_max = dmhi\n        self.shots = shots\n        self.attributes = [x for x in abi if x in keywords]\n        self.hates = [v for (k, v) in haters if k == self.name]\n        self.opp_elem = [v for (k, v) in elementals if k == self.name]\n\n\nclass Stack(object):\n\n    def __init__(self, unit, count):\n        # these values can't change during combat:\n        self.unit = unit\n        self.cap = count\n        self.name = unit.name\n        self.speed = unit.speed\n        self.true_hp = unit.hp\n        self.true_attack = unit.attack\n        self.true_defense = unit.defense\n        self.dmg_min = unit.dmg_min\n        self.dmg_max = unit.dmg_max\n        self.hates = unit.hates\n        self.opp_elem = unit.opp_elem\n        self.attributes = unit.attributes\n\n        if self.name == 'Battle Dwarf':\n            self.magic_resist = .4\n        elif self.name in ['Dwarf', 'Crystal Dragon']:\n            self.magic_resist = .2\n        else:\n            self.magic_resist = 0.\n\n        if self.name == 'Gold Dragon':\n            self.spell_immunity = 4\n        elif self.name in ['Black Dragon', 'Magic Elemental']:\n            self.spell_immunity = 5\n        elif self.name in ['Green Dragon', 'Red Dragon', 'Azure Dragon']:\n            self.spell_immunity = 3\n        else:\n            self.spell_immunity = 0\n\n        # these can:\n        self.reset_state()\n\n    def reset_state(self):\n        self.count = self.cap\n        self.hp = self.true_hp\n        self.hp_left = self.hp\n        self.attack = self.true_attack\n        self.defense = self.true_defense\n        self.shots = self.unit.shots\n\n        self.aged = -1\n        self.poisoned = -1\n        self.times_poisoned = 0\n        self.cursed = 0\n        self.weakened = 0\n        self.diseased = 0\n\n        self.petrified = 0\n        self.blinded = 0\n        self.paralyzed = 0\n        self.stunned_from_retaliation = False\n\n        self.rebirth_available = self.name == 'Phoenix' or False\n\n    def take_dmg(self, dmg):\n        if dmg < self.hp_left:\n            self.hp_left -= dmg\n        else:\n            dmg -= self.hp_left\n            num_killed, rem = my_divmod(dmg, self.hp)\n            self.count -= num_killed + 1\n            self.hp_left = self.hp - rem\n            self.count = max(self.count, 0)\n        if self.name == 'Phoenix' and not self.is_alive() \\\n                and self.rebirth_available:\n            self.rebirth()\n\n    def __calc_base_damage(self, other):\n        real_dmg_max = self.dmg_min if self.cursed > 0 else self.dmg_max\n        if self.count < 10:\n            base_dmg = sum([randint(self.dmg_min, real_dmg_max)\n                            for _ in range(int(self.count))])\n        else:\n            base_dmg = sum([randint(self.dmg_min, real_dmg_max)\n                            for _ in range(10)]) * self.count // 10\n\n        defense = other.defense\n        if self.name == 'Behemoth':\n            defense = int(.6 * defense)\n        elif self.name == 'Ancient Behemoth':\n            defense = int(.2 * defense)\n\n        att_to_def = self.attack - defense\n        base_dmg_reduction = 0.\n        base_dmg_bonus = 0.\n        if att_to_def > 0:\n            base_dmg_bonus = min(.05 * att_to_def, 3.)\n        else:\n            base_dmg_reduction = min(.025 * -att_to_def, .7)\n\n        return base_dmg, base_dmg_bonus, base_dmg_reduction\n\n    # __pragma__('kwargs')\n\n    def attack_melee(self, other, dmg_reductions=None, melee_penalty=False,\n                     retaliation=False):\n        dmg_bonus = 0.\n        if dmg_reductions is None:\n            dmg_reductions = []\n        base_dmg, base_dmg_bonus, base_dmg_reduction = \\\n            self.__calc_base_damage(other)\n        dmg_bonus += base_dmg_bonus\n        dmg_reductions.append(base_dmg_reduction)\n\n        if melee_penalty:\n            dmg_reductions.append(.5)\n\n        if self.name == 'Dread Knight' and random() < .2:\n            dmg_bonus += 1.\n        elif other.name in self.hates:\n            dmg_bonus += .5\n        elif other.name in self.opp_elem:\n            dmg_bonus += 1.\n\n        if self.name == 'Magic Elemental' and other.spell_immunity == 5:\n            dmg_reductions.append(.5)\n        elif self.name == 'Psychic Elemental' and (\n                other.is_nonliving() or other.name in\n                ['Giant', 'Titan', 'Black Dragon']):\n            dmg_reductions.append(.5)\n\n        damage = base_dmg * (1. + dmg_bonus)\n        # fire shield looks at damage before reductions\n        # damage dealt is at most 20% of total HP of Efreet stack\n        fire_shield_damage = .2 * \\\n            min(damage, (other.count - 1) * other.hp + other.hp_left)\n\n        for reduction in dmg_reductions:\n            damage *= 1. - reduction\n\n        damage = int(damage)\n        other.take_dmg(damage)\n\n        other.petrified = 0\n        other.blinded = 0\n        other.paralyzed = 0\n        other.stunned_from_retaliation = False\n\n        if (self.name == 'Vampire Lord' and\n                not other.is_nonliving()):\n            self.drain_life(damage)\n        elif (self.name == 'Mighty Gorgon' and\n                not other.is_nonliving()):\n            self.death_stare(other)\n        elif (self.name == 'Thunderbird' and\n              other.spell_immunity < 2 and\n              other.name not in ['Earth Elemental', 'Magma Elemental'] and\n              random() < .2 and\n              random() > other.magic_resist):\n            self.thunderbolt(other)\n        elif self.name == 'Rust Dragon':\n            self.acid_breath(other)\n        elif (self.name == 'Ghost Dragon' and\n              not other.is_nonliving() and\n              random() < .2):\n            other.start_aging()\n        elif (self.name == 'Wyvern Monarch' and\n                other.times_poisoned < 5 and\n                not other.is_nonliving() and\n                random() < .2):\n            other.start_poison()\n        elif (self.name in ['Black Knight', 'Dread Knight', 'Mummy'] and\n              other.spell_immunity < 1 and\n              not other.is_undead() and\n              other.name not in [\n                  'Efreet', 'Efreet Sultan', 'Fire Elemental',\n                  'Energy Elemental', 'Firebird', 'Phoenix'] and\n              random() > other.magic_resist):\n            if ((self.name == 'Mummy' and random() < .5) or\n                    (self.name != 'Mummy' and random() < .2)):\n                self.start_curse(other)\n        elif (self.name == 'Dragon Fly' and\n              other.spell_immunity < 2 and\n              random() > other.magic_resist):\n            self.start_weakness(other)\n        elif (self.name == 'Zombie' and\n              not other.is_nonliving() and\n              random() < .2):\n            self.start_disease(other)\n        elif (self.name in ['Medusa', 'Medusa Queen', 'Basilisk',\n                            'Greater Basilisk'] and\n              other.spell_immunity == 0 and\n              other.name not in ['Troglodyte', 'Infernal Troglodyte'] and\n              random() < .2):\n            self.start_petrification(other)\n            other.stunned_from_retaliation = retaliation\n        elif (self.name in ['Unicorn', 'War Unicorn'] and\n              other.spell_immunity < 2 and\n              not other.is_nonliving() and\n              other.name not in [\n                  'Troglodyte', 'Infernal Troglodyte', 'Giant', 'Titan',\n                  'Efreet', 'Efreet Sultan', 'Firebird', 'Phoenix'] and\n              random() < .2):\n            self.start_blindness(other)\n            other.stunned_from_retaliation = retaliation\n        elif (self.name == 'Scorpicore' and\n              other.name not in ['Gold Dragon', 'Black Dragon',\n                                 'Magic Elemental'] and\n              random() < .2):\n            self.start_paralysis(other)\n            other.stunned_from_retaliation = retaliation\n\n        if (other.name == 'Efreet Sultan' and\n            self.name not in [\n                'Efreet', 'Efreet Sultan', 'Fire Elemental',\n                'Energy Elemental', 'Firebird', 'Phoenix']):\n            self.efreet_fire_shield(fire_shield_damage)\n\n    # __pragma__('nokwargs')\n\n    def attack_range(self, other, range_penalty):\n        assert self.is_shooter() and self.shots > 0\n        dmg_bonus = 0.\n        base_dmg, base_dmg_bonus, base_dmg_reduction = \\\n            self.__calc_base_damage(other)\n        dmg_bonus += base_dmg_bonus\n\n        damage = base_dmg * (1. + dmg_bonus) * (1. - base_dmg_reduction)\n        if range_penalty:\n            damage /= 2.\n\n        other.take_dmg(int(damage))\n        self.shots -= 1\n\n    def start_weakness(self, other):\n        assert self.name == 'Dragon Fly'\n        if self.speed > other.speed:\n            other.weakened = 3\n        elif self.speed < other.speed:\n            other.weakened = 2\n        else:\n            other.weakened = randint(2, 3)\n        other.attack = max(0, other.true_attack - 6)\n\n    def weakness(self):\n        assert self.weakened > 0\n        self.weakened -= 1\n        if self.weakened == 0:\n            self.attack = self.true_attack\n\n    def start_curse(self, other):\n        assert self.name in ['Mummy', 'Black Knight', 'Dread Knight']\n        if self.speed > other.speed:\n            other.cursed = 3\n        elif self.speed < other.speed:\n            other.cursed = 2\n        else:\n            other.cursed = randint(2, 3)\n\n    def curse(self):\n        assert self.cursed > 0\n        self.cursed -= 1\n\n    def start_disease(self, other):\n        assert self.name == 'Zombie'\n        if self.speed > other.speed:\n            other.diseased = 3\n        elif self.speed < other.speed:\n            other.diseased = 2\n        else:\n            other.diseased = randint(2, 3)\n        other.attack = max(0, other.true_attack - 2)\n        other.defense = max(0, other.true_defense - 2)\n\n    def disease(self):\n        assert self.diseased > 0\n        self.diseased -= 1\n        if self.diseased == 0:\n            self.attack = self.true_attack\n            self.defense = self.true_defense\n\n    def start_petrification(self, other):\n        assert self.name in ['Medusa', 'Medusa Queen', 'Basilisk',\n                             'Greater Basilisk']\n        if self.speed > other.speed:\n            other.petrified = 3\n        elif self.speed < other.speed:\n            other.petrified = 2\n        else:\n            other.petrified = randint(2, 3)\n\n    def petrification(self):\n        assert self.petrified > 0\n        self.petrified -= 1\n\n    def start_blindness(self, other):\n        assert self.name in ['Unicorn', 'War Unicorn']\n        if self.speed > other.speed:\n            other.blinded = 3\n        elif self.speed < other.speed:\n            other.blinded = 2\n        else:\n            other.blinded = randint(2, 3)\n\n    def blindness(self):\n        assert self.blinded > 0\n        self.blinded -= 1\n\n    def start_paralysis(self, other):\n        assert self.name == 'Scorpicore'\n        if self.speed > other.speed:\n            other.paralyzed = 3\n        elif self.speed < other.speed:\n            other.paralyzed = 2\n        else:\n            other.paralyzed = randint(2, 3)\n\n    def paralysis(self):\n        assert self.paralyzed > 0\n        self.paralyzed -= 1\n\n    def start_aging(self):\n        was_already_aged = self.aged > 0\n        self.aged = 3 if self.speed < 14 else 2\n        if not was_already_aged:\n            hp_missing = self.hp - self.hp_left\n            self.hp = (self.hp + 1) // 2\n            self.hp_left = max(1, self.hp - hp_missing)\n\n    def age(self):\n        assert self.aged > 0\n        self.aged -= 1\n        if self.aged == 0:\n            self.stop_aging()\n\n    def stop_aging(self):\n        assert self.aged == 0\n        self.aged = -1\n        hp_missing = self.hp - self.hp_left\n        self.hp = self.true_hp\n        self.hp_left = self.hp - hp_missing\n\n    def start_poison(self):\n        was_already_poisoned = self.poisoned >= 0\n        self.poisoned = 2\n        if not was_already_poisoned:\n            self.times_poisoned += 1\n            hp_missing = self.hp - self.hp_left\n            self.hp = int(ceil(self.true_hp *\n                               (1 - .1 * self.times_poisoned)))\n            self.hp_left = max(1, self.hp - hp_missing)\n\n    def poison(self):\n        assert self.poisoned >= 0\n        self.poisoned -= 1\n        if self.times_poisoned < 5 and self.poisoned >= 0:\n            self.times_poisoned += 1\n            hp_missing = self.hp - self.hp_left\n            self.hp = int(ceil(self.true_hp *\n                               (1 - .1 * self.times_poisoned)))\n            self.hp_left = max(1, self.hp - hp_missing)\n\n    def drain_life(self, damage_dealt):\n        assert self.name == 'Vampire Lord'\n        if self.hp_left + damage_dealt <= self.hp:\n            self.hp_left += damage_dealt\n        else:\n            damage_dealt -= self.hp - self.hp_left\n            self.hp_left = self.hp\n            res, rem = my_divmod(damage_dealt, self.hp)\n            self.count = min(self.cap, self.count + res)\n            if self.count < self.cap and rem:\n                self.count += 1\n                self.hp_left = rem\n\n    def acid_breath(self, other):\n        other.defense = max(0, other.defense - 3)\n        if random() < .3:\n            other.take_dmg(25 * self.count)\n\n    def magic_dmg_resistance(self):\n        if self.name == 'Stone Golem':\n            return .5\n        elif self.name == 'Iron Golem':\n            return .75\n        elif self.name == 'Gold Golem':\n            return .85\n        elif self.name == 'Diamond Golem':\n            return .95\n        return 0.\n\n    def efreet_fire_shield(self, damage):\n        damage *= (1. - self.magic_dmg_resistance())\n        if self.name in ['Water Elemental', 'Ice Elemental']:\n            damage *= 2\n        self.take_dmg(int(damage))\n\n    def thunderbolt(self, other):\n        assert self.name == 'Thunderbird'\n        damage = 10 * self.count\n        damage *= (1 - other.magic_dmg_resistance())\n        if self.name in ['Air Elemental', 'Storm Elemental']:\n            damage *= 2\n        other.take_dmg(int(damage))\n\n    def death_stare(self, other):\n        assert self.name == 'Mighty Gorgon' and not other.is_nonliving()\n        to_death_stare = min(my_binomial(self.count, .1),\n                             (self.count + 9) // 10)\n        if to_death_stare:\n            other.count = max(0, other.count - to_death_stare)\n            other.hp_left = other.hp\n\n    def rebirth(self):\n        assert (self.name == 'Phoenix' and not self.is_alive() and\n                self.rebirth_available)\n        certain, rem = my_divmod(self.count, 5)\n        to_rebirth = certain + (random() < .2*rem)\n        self.count = to_rebirth\n        self.rebirth_available = False\n\n    def regenerate(self):\n        assert self.name in ['Wight', 'Wraith', 'Troll']\n        self.hp_left = self.hp\n\n    def is_alive(self):\n        return self.count > 0\n\n    def is_shooter(self):\n        return 'SHOOTING_ARMY' in self.attributes\n\n    def strikes_twice(self):\n        return 'const_two_attacks' in self.attributes and not self.is_shooter()\n\n    def shoots_twice(self):\n        return 'const_two_attacks' in self.attributes and self.is_shooter()\n\n    def is_big(self):\n        return 'DOUBLE_WIDE' in self.attributes\n\n    def melee_penalty(self):\n        return (self.is_shooter() and\n                not 'const_no_melee_penalty' in self.attributes)\n\n    def no_retaliation(self):\n        return 'const_free_attack' in self.attributes\n\n    def range_penalty(self):\n        return self.is_shooter() and self.name != 'Sharpshooter'\n\n    def is_elemental(self):\n        return 'cusELEMENTAL' in self.attributes\n\n    def is_undead(self):\n        return 'IS_UNDEAD' in self.attributes\n\n    def is_golem(self):\n        return 'cusGOLEM' in self.attributes\n\n    def is_nonliving(self):\n        return self.is_elemental() or self.is_undead() or self.is_golem()\n\n    def is_stunned(self):\n        return bool(self.petrified or self.blinded or self.paralyzed)\n\n    def advance_statuses(self):\n        if self.aged > 0 and self.is_alive():\n            self.age()\n        elif self.poisoned >= 0 and self.is_alive():\n            self.poison()\n        elif self.cursed:\n            self.curse()\n        elif self.weakened:\n            self.weakness()\n        elif self.diseased:\n            self.disease()\n        elif self.petrified:\n            self.petrification()\n        elif self.blinded:\n            self.blindness()\n        elif self.paralyzed:\n            self.paralysis()\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AAcA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AAGA;AACA;AAAA;AAGA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAKA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAIA;AACA;AAAA;AAOA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAOA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;AAIA;AAAA;AAEA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAGA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}